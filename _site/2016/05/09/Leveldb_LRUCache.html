<!DOCTYPE html>
<html lang="zh-CN">
    <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Leveldb之LRUCache实现</title>
  <meta name="description" content="leveldb代码读完也有好一阵子了，其实早想好好的写博客从头到尾系统总结一遍，不过它真的是写的太好了，任何一个地方单拿出来都可以写好多，想向TCMalloc那样自下而上写一个系列的话我估计写30篇都写不完…所以就挑着一些主题写写吧，有些是和leveldb强相关的比如迭代器，compact的实现，有些是相对独立、...">

  <link rel="canonical" href="https://kernelmaker.github.io/2016/05/09/Leveldb_LRUCache.html">

  <link rel="stylesheet" href="/assets/css/bootstrap.min.css">
  <!-- <link rel="stylesheet" href="/assets/css/icard_resume.css"> -->
  <link rel="stylesheet" href="/assets/css/font-awesome.min.css">
  <link rel="stylesheet" href="/assets/css/blog.css" >
  <link rel="stylesheet" href="/assets/css/syntax.css">

  <link rel="icon" type="image/png" href="/assets/img/avatar.jpeg">

  <!-- Google fonts -->
  <link rel='stylesheet' href='//fonts.googleapis.com/css?family=Open+Sans:300' type='text/css'>
  <link rel='stylesheet' href='//fonts.googleapis.com/css?family=Source+Sans+Pro' type='text/css'>

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
  <script src="assets/js/html5shiv.min.js"></script>
  <script src="assets/js/respond.min.js"></script>
  <![endif]-->

</head>

    <body>
        <header class="bloghead">
    <dev class="authorheader">
        <a href="/">
            <img alt="My Avatar" src="/assets/img/avatar.jpeg"/>
        </a>
        <dev class="blogtitle">
            <h1><a href="/">KernelMaker</a></h1>
            <h5> 墨鱼丸是只猫 </h5>
        </dev>
    </dev>

    <nav class="menu" role="nav">
        <ul>
            <li><a href="/">Home</a></li>
            <li>|</li>
            <li><a href="/menu.html">Menu</a></li>
            <li>|</li>
            <li><a target="_blank" href="https://github.com/kernelmaker">Github</a></li>
            <li>|</li>
            <li><a target="_blank" href="/about.html"> About Me</a></li>
        </ul>
    </nav>
</header>


        <main class="blogmain">
            <header>
                <h1 class="article-title">Leveldb之LRUCache实现</h1>
                <p class="article-time">
                    2016年05月09日 星期一,  发表于 <span>北京</span>
                </p>
                <p class="article-hint">
                    如果您对本文有任何的建议或者疑问, 可以下方留言或者在
                    <a href="https://github.com/kernelmaker/kernelmaker.github.io/issues" target="_blank">这里给我提 Issues</a>, 谢谢! :)
                </p>
            </header>
            <p>leveldb代码读完也有好一阵子了，其实早想好好的写博客从头到尾系统总结一遍，不过它真的是写的太好了，任何一个地方单拿出来都可以写好多，想向TCMalloc那样自下而上写一个系列的话我估计写30篇都写不完…所以就挑着一些主题写写吧，有些是和leveldb强相关的比如迭代器，compact的实现，有些是相对独立、可以用来学习编程的比如LRUCache、SkipList的实现，今天就先说说LRUCache的实现吧</p>

<h2 id="section">介绍</h2>
<p>leveldb在Table和VersionSet的实现中用到了LRUCache，分别给Block和Table加了缓存，加快访问速度，并且当缓存满了淘汰最近最少使用的那个。这篇先不管什么是Block什么是Table，就单纯的来看看levedb的LRUCache是怎么实现的</p>

<h2 id="section-1">原理</h2>

<p>LRUCache想必都不陌生，就是一个缓存，不过既然是缓存肯定容量有限，当缓存满了后，需要淘汰一个最近最少使用的item。怎么实现呢？也不难，无非是一个HashTable配合一个List就可以了，HashTable用来存item，List按每个item最近使用的先后顺序将所有item排序，tail的item是最近使用的，head的item是最久没使用的，要淘汰就从head开始，当用户访问完某个item，就将该item从List中拿出来再插到最尾，这样就是一个LRUCache的实现啦</p>

<h2 id="section-2">实现</h2>

<p>那么leveldb是怎么实现的呢？其实和上面说的差不多，不过具体实现中还是可以看出大牛的功底，一点一点来看，先说说item的实现，在leveldb中，HashTable中保存的item叫做LRUHandle，定义如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">LRUHandle</span> <span class="p">{</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">value</span><span class="p">;</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">deleter</span><span class="p">)(</span><span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">value</span><span class="p">);</span> <span class="c1">// 清理回调函数，用来在释放时做资源回收
</span>  <span class="n">LRUHandle</span><span class="o">*</span> <span class="n">next_hash</span><span class="p">;</span> <span class="c1">// hash冲突时线性探测
</span>  <span class="n">LRUHandle</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span> <span class="c1">// List的next
</span>  <span class="n">LRUHandle</span><span class="o">*</span> <span class="n">prev</span><span class="p">;</span> <span class="c1">// List的prev
</span>  <span class="kt">size_t</span> <span class="n">charge</span><span class="p">;</span>      <span class="c1">// TODO(opt): Only allow uint32_t?
</span>  <span class="kt">size_t</span> <span class="n">key_length</span><span class="p">;</span> <span class="c1">//key的长度
</span>  <span class="kt">uint32_t</span> <span class="n">refs</span><span class="p">;</span> <span class="c1">// 引用计数
</span>  <span class="kt">uint32_t</span> <span class="n">hash</span><span class="p">;</span>      <span class="c1">// Hash of key(); used for fast sharding and comparisons
</span>  <span class="kt">char</span> <span class="n">key_data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>   <span class="c1">// Beginning of key
</span>
  <span class="n">Slice</span> <span class="nf">key</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="c1">// For cheaper lookups, we allow a temporary Handle object
</span>    <span class="c1">// to store a pointer to a key in "value".
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="k">this</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">Slice</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">Slice</span><span class="p">(</span><span class="n">key_data</span><span class="p">,</span> <span class="n">key_length</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre>
</div>

<p>next_hash是在hash冲突时线性探测后续LRUHandle用到的，next和prev是记录List的节点信息，我们发现leveldb在具体实现中，将上一节说到的HashTable中的item和List中的节点揉在了一起，这样HashTable中的每个元素不仅记录着冲突hash值的下一个元素，还记录着LRU顺序</p>

<p>LRUHandle定义完了，接下来就是HashTable的实现了，在levledb叫HandleTable，代码如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">HandleTable</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">HandleTable</span><span class="p">()</span> <span class="o">:</span> <span class="n">length_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">elems_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">list_</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="n">Resize</span><span class="p">();</span> <span class="p">}</span>
  <span class="o">~</span><span class="n">HandleTable</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span><span class="p">[]</span> <span class="n">list_</span><span class="p">;</span> <span class="p">}</span>

  <span class="n">LRUHandle</span><span class="o">*</span> <span class="n">Lookup</span><span class="p">(</span><span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">hash</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">FindPointer</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">LRUHandle</span><span class="o">*</span> <span class="n">Insert</span><span class="p">(</span><span class="n">LRUHandle</span><span class="o">*</span> <span class="n">h</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">LRUHandle</span><span class="o">**</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">FindPointer</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">(),</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">);</span> <span class="c1">// 先在当前HandleTable中查找有没有包含h-&gt;key的LRUHandle，如果有的话则返回保存该LRUHandle地址的内存地址，也就是该LRUHandle的前一个LRUHandle的next字段地址
</span>    <span class="n">LRUHandle</span><span class="o">*</span> <span class="n">old</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span> <span class="c1">//对上一步返回的ptr解引用得到对应LRUHandle地址，也就是之前存在的LRUHandle地址，赋值给old
</span>    <span class="n">h</span><span class="o">-&gt;</span><span class="n">next_hash</span> <span class="o">=</span> <span class="p">(</span><span class="n">old</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">?</span> <span class="nb">NULL</span> <span class="o">:</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">next_hash</span><span class="p">);</span> <span class="c1">// 将h的next_hash赋值为old的next_hash
</span>    <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span> <span class="c1">//将ptr的值也就是对应LRUHandle前一个LRUHandle的next字段赋值为h，这样就将h插入到了桶中，old移出桶
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">old</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">++</span><span class="n">elems_</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">elems_</span> <span class="o">&gt;</span> <span class="n">length_</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//当前存的元素个数大于桶的个数，扩容
</span>        <span class="c1">// Since each cache entry is fairly large, we aim for a small
</span>        <span class="c1">// average linked list length (&lt;= 1).
</span>        <span class="n">Resize</span><span class="p">();</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">old</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">LRUHandle</span><span class="o">*</span> <span class="n">Remove</span><span class="p">(</span><span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">hash</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">LRUHandle</span><span class="o">**</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">FindPointer</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>
    <span class="n">LRUHandle</span><span class="o">*</span> <span class="n">result</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">next_hash</span><span class="p">;</span>
      <span class="o">--</span><span class="n">elems_</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="k">private</span><span class="o">:</span>
  <span class="c1">// The table consists of an array of buckets where each bucket is
</span>  <span class="c1">// a linked list of cache entries that hash into the bucket.
</span>  <span class="kt">uint32_t</span> <span class="n">length_</span><span class="p">;</span> <span class="c1">// hash桶数
</span>  <span class="kt">uint32_t</span> <span class="n">elems_</span><span class="p">;</span> <span class="c1">// 当前有多少个元素
</span>  <span class="n">LRUHandle</span><span class="o">**</span> <span class="n">list_</span><span class="p">;</span> <span class="c1">// 桶数组
</span>
  <span class="c1">// Return a pointer to slot that points to a cache entry that
</span>  <span class="c1">// matches key/hash.  If there is no such cache entry, return a
</span>  <span class="c1">// pointer to the trailing slot in the corresponding linked list.
</span>  <span class="c1">// 通过hash值在对应桶中查找key，注意：如果存在则返回保存改LRUHandle地址的内存地址，不存在则返回空
</span>  <span class="n">LRUHandle</span><span class="o">**</span> <span class="nf">FindPointer</span><span class="p">(</span><span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">hash</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">LRUHandle</span><span class="o">**</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">list_</span><span class="p">[</span><span class="n">hash</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">length_</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)];</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
           <span class="p">((</span><span class="o">*</span><span class="n">ptr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">!=</span> <span class="n">hash</span> <span class="o">||</span> <span class="n">key</span> <span class="o">!=</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">()))</span> <span class="p">{</span>
      <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next_hash</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// 扩容
</span>  <span class="kt">void</span> <span class="nf">Resize</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">new_length</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">new_length</span> <span class="o">&lt;</span> <span class="n">elems_</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">new_length</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">LRUHandle</span><span class="o">**</span> <span class="n">new_list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LRUHandle</span><span class="o">*</span><span class="p">[</span><span class="n">new_length</span><span class="p">];</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">new_list</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">new_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">new_length</span><span class="p">);</span>
    <span class="kt">uint32_t</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length_</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">LRUHandle</span><span class="o">*</span> <span class="n">h</span> <span class="o">=</span> <span class="n">list_</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">h</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">LRUHandle</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">next_hash</span><span class="p">;</span>
        <span class="kt">uint32_t</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">;</span>
        <span class="n">LRUHandle</span><span class="o">**</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">new_list</span><span class="p">[</span><span class="n">hash</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">new_length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)];</span>
        <span class="n">h</span><span class="o">-&gt;</span><span class="n">next_hash</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
        <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
        <span class="n">count</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">elems_</span> <span class="o">==</span> <span class="n">count</span><span class="p">);</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">list_</span><span class="p">;</span>
    <span class="n">list_</span> <span class="o">=</span> <span class="n">new_list</span><span class="p">;</span>
    <span class="n">length_</span> <span class="o">=</span> <span class="n">new_length</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

</code></pre>
</div>

<p>实现不难，不过有一点值得特殊说一下，自己理解的单向链表的Insert操作一般可以分成两步，第一步是FindPoint，来找到要插入的位置cur，第二步是在FindPoint返回的位置cur之前插入一个新的元素，这里似乎有点问题，因为一般链表的插入需要拿到cur的前一个元素并修改其next指针，但FindPoint只返回的cur，并没有返回cur的前一个元素地址，难道要返回两个指针吗？其实不用，leveldb是这么做的，FindPoint返回的并不是要插入位置元素的地址，而是保存改地址内存的地址，也就是cur前一个元素next字段的地址ptr，这样就一举两得了，通过*ptr可以找到cur，通过修改ptr-&gt;next可以直接修改前一个元素的next字段，很巧妙</p>

<p>好了，HandleTable实现完了，现在就可以实现LRUCache了，代码如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// A single shard of sharded cache.
</span><span class="k">class</span> <span class="nc">LRUCache</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">LRUCache</span><span class="p">();</span>
  <span class="o">~</span><span class="n">LRUCache</span><span class="p">();</span>

  <span class="c1">// Separate from constructor so caller can easily make an array of LRUCache
</span>  <span class="kt">void</span> <span class="nf">SetCapacity</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">capacity</span><span class="p">)</span> <span class="p">{</span> <span class="n">capacity_</span> <span class="o">=</span> <span class="n">capacity</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Like Cache methods, but with an extra "hash" parameter.
</span>  <span class="n">Cache</span><span class="o">::</span><span class="n">Handle</span><span class="o">*</span> <span class="n">Insert</span><span class="p">(</span><span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">hash</span><span class="p">,</span>
                        <span class="kt">void</span><span class="o">*</span> <span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">charge</span><span class="p">,</span>
                        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">deleter</span><span class="p">)(</span><span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">value</span><span class="p">));</span>
  <span class="n">Cache</span><span class="o">::</span><span class="n">Handle</span><span class="o">*</span> <span class="n">Lookup</span><span class="p">(</span><span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">hash</span><span class="p">);</span>
  <span class="kt">void</span> <span class="n">Release</span><span class="p">(</span><span class="n">Cache</span><span class="o">::</span><span class="n">Handle</span><span class="o">*</span> <span class="n">handle</span><span class="p">);</span>
  <span class="kt">void</span> <span class="n">Erase</span><span class="p">(</span><span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">hash</span><span class="p">);</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">LRU_Remove</span><span class="p">(</span><span class="n">LRUHandle</span><span class="o">*</span> <span class="n">e</span><span class="p">);</span> <span class="c1">//修改e的next和prev指针，从lru_中移除
</span>  <span class="kt">void</span> <span class="n">LRU_Append</span><span class="p">(</span><span class="n">LRUHandle</span><span class="o">*</span> <span class="n">e</span><span class="p">);</span> <span class="c1">//修改e的next和prev指针，插入lru_中
</span>  <span class="kt">void</span> <span class="n">Unref</span><span class="p">(</span><span class="n">LRUHandle</span><span class="o">*</span> <span class="n">e</span><span class="p">);</span> <span class="c1">//减少e的引用计数，如果为0就释放e
</span>
  <span class="c1">// Initialized before use.
</span>  <span class="kt">size_t</span> <span class="n">capacity_</span><span class="p">;</span>

  <span class="c1">// mutex_ protects the following state.
</span>  <span class="n">port</span><span class="o">::</span><span class="n">Mutex</span> <span class="n">mutex_</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">usage_</span><span class="p">;</span>

  <span class="c1">// Dummy head of LRU list.
</span>  <span class="c1">// lru.prev is newest entry, lru.next is oldest entry.
</span>  <span class="n">LRUHandle</span> <span class="n">lru_</span><span class="p">;</span> <span class="c1">//lru list的head节点，今后prev指向最新节点，next指向最老节点，每次淘汰next，初始都指向自己
</span>
  <span class="n">HandleTable</span> <span class="n">table_</span><span class="p">;</span> <span class="c1">//包含一个HandleTable
</span><span class="p">};</span>

<span class="kt">void</span> <span class="n">LRUCache</span><span class="o">::</span><span class="n">LRU_Remove</span><span class="p">(</span><span class="n">LRUHandle</span><span class="o">*</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">LRUCache</span><span class="o">::</span><span class="n">LRU_Append</span><span class="p">(</span><span class="n">LRUHandle</span><span class="o">*</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Make "e" newest entry by inserting just before lru_
</span>  <span class="n">e</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lru_</span><span class="p">;</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">lru_</span><span class="p">.</span><span class="n">prev</span><span class="p">;</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Cache</span><span class="o">::</span><span class="n">Handle</span><span class="o">*</span> <span class="n">LRUCache</span><span class="o">::</span><span class="n">Lookup</span><span class="p">(</span><span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">hash</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MutexLock</span> <span class="n">l</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex_</span><span class="p">);</span>
  <span class="c1">//从HandleTable中查找是否存在key的LRUHandler
</span>  <span class="n">LRUHandle</span><span class="o">*</span> <span class="n">e</span> <span class="o">=</span> <span class="n">table_</span><span class="p">.</span><span class="n">Lookup</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//因为要返回给用户，所以引用数+1
</span>    <span class="n">e</span><span class="o">-&gt;</span><span class="n">refs</span><span class="o">++</span><span class="p">;</span>
    <span class="c1">//从lru_中移除
</span>    <span class="n">LRU_Remove</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
    <span class="c1">//插入到lru_的prev位置，这样e的淘汰优先级就最低
</span>    <span class="n">LRU_Append</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">Cache</span><span class="o">::</span><span class="n">Handle</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">LRUCache</span><span class="o">::</span><span class="n">Release</span><span class="p">(</span><span class="n">Cache</span><span class="o">::</span><span class="n">Handle</span><span class="o">*</span> <span class="n">handle</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MutexLock</span> <span class="n">l</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex_</span><span class="p">);</span>
  <span class="n">Unref</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">LRUHandle</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">handle</span><span class="p">));</span>
<span class="p">}</span>

</code></pre>
</div>
<p>实现的很清晰，重点再看一下Insert：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">Cache</span><span class="o">::</span><span class="n">Handle</span><span class="o">*</span> <span class="n">LRUCache</span><span class="o">::</span><span class="n">Insert</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">hash</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">charge</span><span class="p">,</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">deleter</span><span class="p">)(</span><span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">value</span><span class="p">))</span> <span class="p">{</span>
  <span class="n">MutexLock</span> <span class="n">l</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex_</span><span class="p">);</span>
  
  <span class="c1">//LRUHandle中key_data是最后一个元素，定义是char[1]，这里有一个技巧，就是定义中虽然key_data长度为1个字节，但在实际生成时，malloc的空间大小是sizeof(LRUHandle)-1 + key.size()，刚好key_data是最后一个元素，这样从它开始以后的空间是实际存放key的位置，对于结构体中变长字符数组的定义可以学习这样的方式，很不错
</span>  <span class="n">LRUHandle</span><span class="o">*</span> <span class="n">e</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">LRUHandle</span><span class="o">*&gt;</span><span class="p">(</span>
      <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LRUHandle</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="n">key</span><span class="p">.</span><span class="n">size</span><span class="p">()));</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">deleter</span> <span class="o">=</span> <span class="n">deleter</span><span class="p">;</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">charge</span> <span class="o">=</span> <span class="n">charge</span><span class="p">;</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">key_length</span> <span class="o">=</span> <span class="n">key</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">=</span> <span class="n">hash</span><span class="p">;</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">refs</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// One from LRUCache, one for the returned handle，引用计数初始为2，一个是LRUCache在用，一个是返回给用户
</span>  <span class="n">memcpy</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">key_data</span><span class="p">,</span> <span class="n">key</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">key</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="c1">//插入到lru_的prev位置，最低淘汰优先级
</span>  <span class="n">LRU_Append</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
  <span class="n">usage_</span> <span class="o">+=</span> <span class="n">charge</span><span class="p">;</span>

  <span class="n">LRUHandle</span><span class="o">*</span> <span class="n">old</span> <span class="o">=</span> <span class="n">table_</span><span class="p">.</span><span class="n">Insert</span><span class="p">(</span><span class="n">e</span><span class="p">);</span> <span class="c1">//将e插入到HandleTable中，返回的是存放该key老值的LRUHandle指针
</span>  <span class="k">if</span> <span class="p">(</span><span class="n">old</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//老的LRUHandle已经没用，从lru_中移除
</span>    <span class="n">LRU_Remove</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
    <span class="c1">//减少引用，为0时释放
</span>    <span class="n">Unref</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">//如果已经存满，则淘汰最近最少使用的LRUHandle，也就是lur_的next所指
</span>  <span class="k">while</span> <span class="p">(</span><span class="n">usage_</span> <span class="o">&gt;</span> <span class="n">capacity_</span> <span class="o">&amp;&amp;</span> <span class="n">lru_</span><span class="p">.</span><span class="n">next</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">lru_</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">LRUHandle</span><span class="o">*</span> <span class="n">old</span> <span class="o">=</span> <span class="n">lru_</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
    <span class="n">LRU_Remove</span><span class="p">(</span><span class="n">old</span><span class="p">);</span> <span class="c1">//从lru_中移除
</span>    <span class="n">table_</span><span class="p">.</span><span class="n">Remove</span><span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">(),</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">);</span> <span class="c1">//从HandleTable中移除
</span>    <span class="n">Unref</span><span class="p">(</span><span class="n">old</span><span class="p">);</span> <span class="c1">//减少引用
</span>  <span class="p">}</span>

  <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">Cache</span><span class="o">::</span><span class="n">Handle</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>关键位置已经注释了，不难，至此，LRUCache已经实现差不多了，这时候已经可以结束了，不过leveldb在上面又封了一层ShardedLRUCache，其实就是包了多了LRUCache，这样每个key会定位两次，第一次是用hash值的高4位做shard，算出具体该访问哪个LRUCache，第二次同样的hash值访问LRUCache的某个桶，就是一层封装，不难，直接看实现：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">kNumShardBits</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">kNumShards</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">kNumShardBits</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">ShardedLRUCache</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Cache</span> <span class="p">{</span>
 <span class="k">private</span><span class="o">:</span>
  <span class="n">LRUCache</span> <span class="n">shard_</span><span class="p">[</span><span class="n">kNumShards</span><span class="p">];</span> <span class="c1">// 16个LRUCache
</span>  <span class="n">port</span><span class="o">::</span><span class="n">Mutex</span> <span class="n">id_mutex_</span><span class="p">;</span>
  <span class="kt">uint64_t</span> <span class="n">last_id_</span><span class="p">;</span>

  <span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint32_t</span> <span class="nf">HashSlice</span><span class="p">(</span><span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Hash</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">static</span> <span class="kt">uint32_t</span> <span class="nf">Shard</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">hash</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//hash值的高4位做shard
</span>    <span class="k">return</span> <span class="n">hash</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">-</span> <span class="n">kNumShardBits</span><span class="p">);</span>
  <span class="p">}</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="k">explicit</span> <span class="n">ShardedLRUCache</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">capacity</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">last_id_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">size_t</span> <span class="n">per_shard</span> <span class="o">=</span> <span class="p">(</span><span class="n">capacity</span> <span class="o">+</span> <span class="p">(</span><span class="n">kNumShards</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="n">kNumShards</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">kNumShards</span><span class="p">;</span> <span class="n">s</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">shard_</span><span class="p">[</span><span class="n">s</span><span class="p">].</span><span class="n">SetCapacity</span><span class="p">(</span><span class="n">per_shard</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">ShardedLRUCache</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
  <span class="k">virtual</span> <span class="n">Handle</span><span class="o">*</span> <span class="n">Insert</span><span class="p">(</span><span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">charge</span><span class="p">,</span>
                         <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">deleter</span><span class="p">)(</span><span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">value</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">HashSlice</span><span class="p">(</span><span class="n">key</span><span class="p">);</span> <span class="c1">//求hash
</span>    <span class="k">return</span> <span class="n">shard_</span><span class="p">[</span><span class="n">Shard</span><span class="p">(</span><span class="n">hash</span><span class="p">)].</span><span class="n">Insert</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">hash</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span> <span class="n">deleter</span><span class="p">);</span> <span class="c1">//插入到对应的LURCache中
</span>  <span class="p">}</span>
  <span class="k">virtual</span> <span class="n">Handle</span><span class="o">*</span> <span class="n">Lookup</span><span class="p">(</span><span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">HashSlice</span><span class="p">(</span><span class="n">key</span><span class="p">);</span> <span class="c1">//求hash
</span>    <span class="k">return</span> <span class="n">shard_</span><span class="p">[</span><span class="n">Shard</span><span class="p">(</span><span class="n">hash</span><span class="p">)].</span><span class="n">Lookup</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span> <span class="c1">//在对应LRUCache中查找
</span>  <span class="p">}</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Release</span><span class="p">(</span><span class="n">Handle</span><span class="o">*</span> <span class="n">handle</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">LRUHandle</span><span class="o">*</span> <span class="n">h</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">LRUHandle</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
    <span class="n">shard_</span><span class="p">[</span><span class="n">Shard</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">)].</span><span class="n">Release</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Erase</span><span class="p">(</span><span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">HashSlice</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
    <span class="n">shard_</span><span class="p">[</span><span class="n">Shard</span><span class="p">(</span><span class="n">hash</span><span class="p">)].</span><span class="n">Erase</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">virtual</span> <span class="kt">void</span><span class="o">*</span> <span class="n">Value</span><span class="p">(</span><span class="n">Handle</span><span class="o">*</span> <span class="n">handle</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">LRUHandle</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">virtual</span> <span class="kt">uint64_t</span> <span class="n">NewId</span><span class="p">()</span> <span class="p">{</span> <span class="c1">//这个是leveldb给block_cache用的，这里可以不用关心
</span>    <span class="n">MutexLock</span> <span class="n">l</span><span class="p">(</span><span class="o">&amp;</span><span class="n">id_mutex_</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">++</span><span class="p">(</span><span class="n">last_id_</span><span class="p">);</span>
  <span class="p">}</span>

</code></pre>
</div>

<h2 id="section-3">总结</h2>

<p>LRUCache看似简单，实现起来的方式确很多，本篇介绍了leveldb关于LRUCache的实现，还是非常经典的，值得学习，另外levedb主题的博客我会持续写下去，不过内容真的太多了，下篇先写写迭代器相关的东西吧^^</p>

            <footer class="article-footer">
    <div class="authorimage">
        <img src="/assets/img/avatar.jpeg" alt="My Avatar" class="img-circle">
    </div>
    <section class="author">
        <h4><a href="/about.html">KernelMaker</a></h4>
        <a href="mailto:songzhao.asm@icloud.com">songzhao.asm@icloud.com</a>
    </section>
</footer>

            <div id="disqus_thread"></div>
<script>
/**
* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');

s.src = '//kernelmaker.disqus.com/embed.js';

s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

        </main>

        <div class="footer-copyright">
    <div class="container-fluid">
        <div class="row-fluid">
            <div class="col-md-12">
                Copyright &copy; 2016 KernelMaker - All rights reserved.
            </div>
        </div>
    </div>
</div>
<script type="text/javascript" src="/assets/js/jquery.min.js"></script>
<script type="text/javascript" src="/assets/js/bootstrap.min.js"></script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-77075031-1', 'auto');
  ga('send', 'pageview');

</script>


    </body>

</html>
